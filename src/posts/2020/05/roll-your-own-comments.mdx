---
title: Roll your own comments with Gatsby and FaunaDB
tags: ["Gatsby", "FaunaDB"]
date: 2020-05-01
author: Paul Scanlon
isPrivate: true
featuredImage: roll-your-own-comments.jpg
embeddedImages:
  - new-database.jpg
  - server-key.jpg
  - comment-in-document.jpg
  - get-all-comments.jpg
  - get-comments-by-slug.jpg
  - new-site-from-git.jpg
  - netlify-identity.jpg
---

If you haven't used Gatsby before have a read about why it's [Fast in every way that matters](https://www.gatsbyjs.org/), and if you haven't used [FaunaDB](https://fauna.com/) before you're in for a treat. If you're looking to make your static sites full blown Jamstack applications this is the back end solution for you!

This tutorial will only focus on the operations you need to use [FaunaDB](https://fauna.com/) to power a comment system for a Gatsby blog. The [app](https://github.com/PaulieScanlon/fauna-gatsby-comments.git) comes complete with inputs fields that allow users to comment on your posts and an admin area for you to approve or delete comments before they appear on each post. Authentication is provided by Netlify's Identity widget and it's all sewn together using Netlify serverless functions and an Apollo/GraphQL API that pushes data up to a FaunaDB database collection.

I chose [FaunaDB](https://fauna.com/) for the database for a number of reasons. Firstly there's a very generous free tier! perfect for those small projects that need a back end, there's native support for GraphQL queries and it has some really powerful indexing features!

...and to quote the creators;

> No matter which stack you use, or where you’re deploying your app, FaunaDB gives you effortless, low-latency and reliable access to your data via APIs familiar to you

You can see the finished comments app [here](https://fauna-gatsby-comments.netlify.app/)

## [Get Started](#get-started)

To get started clone the repo at [https://github.com/PaulieScanlon/fauna-gatsby-comments](https://github.com/PaulieScanlon/fauna-gatsby-comments)

or

```sh
git clone https://github.com/PaulieScanlon/fauna-gatsby-comments.git
```

Then install all the dependencies

<Divider />

```sh
npm install
```

<Divider />

Also cd in to `functions/apollo-graphql` and install the dependencies for the Netlify function.

<Divider />

```sh
npm install
```

<Divider />

This is a separate package and has its own dependencies, you’ll be using this later.

We also need to install the Netlify CLI as you’ll also use this later

<Divider />

```sh
npm install netlify-cli -g
```

<Divider />

Now lets add three new files that aren’t part of the repo.

At the root of your project create a `.env` `.env.development` and `.env.production`

Add the following to `.env`

<Divider />

```sh
GATSBY_FAUNA_DB =
GATSBY_FAUNA_COLLECTION =
```

<Divider />

Add the following to `.env.development`

<Divider />

```sh
GATSBY_FAUNA_DB =
GATSBY_FAUNA_COLLECTION =
GATSBY_SHOW_SIGN_UP = true
GATSBY_ADMIN_ID =


```

<Divider />

Add the following to `.env.production`

<Divider />

```sh
GATSBY_FAUNA_DB =
GATSBY_FAUNA_COLLECTION =
GATSBY_SHOW_SIGN_UP = false
GATSBY_ADMIN_ID =
```

<Divider />

You’ll come back to these later but in case you’re wondering

<Divider />

- `GATSBY_FAUNA_DB` is the FaunaDB secret key for your database
- `GATSBY_FAUNA_COLLECTION` is the FaunaDB collection name
- `GATSBY_SHOW_SIGN_UP` is used to hide the Sign up button when the site is in production
- `GATSBY_ADMIN_ID` is a user id that Netlify Identity will generate for you

<Divider />

If you’re the curious type you can get a taster of the app by running `gatsby develop` or `yarn develop` and then navigate to http://localhost:8000 in your browser.

## [FaunaDB](#fauna-db)

So Let's get cracking, but before we write any operations head over to https://fauna.com/ and sign up!

## [Database and Collection](#database-and-collection)

- Create a new database by clicking **NEW DATABASE**
- Name the database: i’ve called the demo database `fauna-gatsby-comments`
- Create a new Collection by clicking **NEW COLLECTION**
- Name the collection: i've called the demo collection `demo-blog-comments`

<Divider />
<Img fluid={props.embedded.image1.fluid} />
<Divider />

## [Server Key](#server-key)

Now you'll need to to set up a server key. Go to **SECURITY**

- Create a new key by clicking **NEW KEY**
- Select the database you want the key to apply to, `fauna-gatsby-comments` for example
- Set the _Role_ as **Admin**
- Name the server key: i've called the demo key `demo-blog-server-key`

<Divider />
<Img fluid={props.embedded.image2.fluid} />
<Divider />

## [Environment Variables Pt. 1](#environment-variables-part-1)

Copy the server key and add it to `GATSBY_FAUNA_DB` in `.env.development`,`.env.production` and `.env`

You'll also need to add the name of the collection to `GATSBY_FAUNA_COLLECTION` in `.env.development`, `.env.production` and `.env`

Adding these values to `.env` are just so you can test your development FaunaDB operations, which you’ll do next.

Let's start by creating a comment so head back to `boop.js`

<Divider />

```javascript
// boop.js
...
// CREATE COMMENT
createComment: async () => {
  const slug = "/posts/some-post"
  const name = "some name"
  const comment = "some comment"

  const results = await client.query(
    q.Create(q.Collection(COLLECTION_NAME), {
      data: {
        isApproved: false,
        slug: slug,
        date: new Date().toString(),
        name: name,
        comment: comment,
      },
    })
  )
  console.log(JSON.stringify(results, null, 2))
  return {
    commentId: results.ref.id,
  }
},
...
```

<Divider />

The breakdown of this function is as follows;

- `q` is the instance of `faunadb.query`
- `Create` is the FaunaDB method to create an entry within a collection
- `Collection` is area in the database to store the data. It takes the name of the collection as the first argument and a data object as the second.

The second argument is the shape of the data you need to drive the applications comment system.

For now you’re going to hard-code `slug`, `name` and `comment` but in the final app these values are captured by the input form on the posts page and passed in via args

The breakdown for the shape is as follows;

- `isApproved` is the status of the comment and by default it’s false until we approve it in the Admin page
- `slug` is the path to the post where the comment was written
- `date` is the time stamp the comment was written
- `name` is the name the user entered in the comments from
- `comment` is the comment the user entered in the comments form

When you (or a user creates) a comment you're not really interested in dealing with the response because as far as the user is concerned all they'll see is either a success or error message.

After a user has posted a comment it will go in to your Admin queue until you approve it but if you did want to return something you could surface this in the UI by returning something from the `createComment` function

## [Create a comment](#create-a-comment)

If you've hard coded a `slug`, `name` and `comment` you can now run the following in your CLI

<Divider />

```sh
node boop createComment
```

<Divider />

If everything worked correctly you should see a log in your terminal of the new comment.

<Divider />

```sh
{
   "ref": {
     "@ref": {
       "id": "263413122555970050",
       "collection": {
         "@ref": {
           "id": "demo-blog-comments",
           "collection": {
             "@ref": {
               "id": "collections"
             }
           }
         }
       }
     }
   },
   "ts": 1587469179600000,
   "data": {
     "isApproved": false,
     "slug": "/posts/some-post",
     "date": "Tue Apr 21 2020 12:39:39 GMT+0100 (British Summer Time)",
     "name": "some name",
     "comment": "some comment"
   }
 }
 { commentId: '263413122555970050' }

```

<Divider />

If you head over to **COLLECTIONS** in FaunaDB you should see your new entry in the collection

<Divider />
<Img fluid={props.embedded.image3.fluid} />
<Divider />

You'll need to create a few more comments while in development so change the hard-coded values for `name` and `comment` and run the following again.

<Divider />

```sh
node boop createComment

```

<Divider />

Do this a few times so you end up with at least three new comments stored in the database, you’ll use these in a moment.

## [Delete comment by id](#delete-comment-by-id)

Now that you can create comments you'll also need to be able to delete a comment.

By adding the `commentId` of one of the comments you created above you can delete it from the database. The `commentId` is the `id` in the `ref.@ref` object

Again you're not really concerned with the return value here but if you wanted to surface this in the UI you could do so by returning something from the `deleteCommentById` function

```javascript
// boop.js
...
// DELETE COMMENT
deleteCommentById: async () => {
  const commentId = "263413122555970050";

  const results = await client.query(
    q.Delete(q.Ref(q.Collection(COLLECTION_NAME), commentId))
  );
  console.log(JSON.stringify(results, null, 2));
  return {
    commentId: results.ref.id,
  };
},
...
```

<Divider />

The breakdown of this function is as follows

- `client` is the FaunaDB client instance
- `query` is a method to get data from FaunaDB
- `q` is the instance of `faunadb.query`
- `Delete` is the FaunaDB delete method to delete entries from a collection
- `Ref` is the unique FaunaDB ref used to identify the entry
- `Collection` is area in the database where the data is stored

If you've hard coded a `commentId` you can now run the following in your CLI

<Divider />

```sh
node boop deleteCommentById
```

<Divider />

If you head back over to **COLLECTIONS** in FaunaDB you should see that entry no longer exists in collection

## [Indexes](#indexes)

Next you're going to create an **INDEX** in FaunaDB.

An **INDEX** allows you to query the database with a specific term and define a specific data shape to return.

When working with GraphQL and / or TypeScript this is really powerful because you can use FaunaDB indexes to return _only_ the data you need and in a predictable shape. This makes data typing responses in GraphQL and / TypeScript a dream... i've worked on a number of applications that just return a massive object of useless values which will inevitably cause bugs in your app. blurg!

<Divider />
<Img fluid={props.embedded.image4.fluid} />
<Divider />

- Go to **INDEXES** and click **NEW INDEX**
- Name the index: i’ve called this one `get-all-comments`
- Set the **source collection** to the name of the collection you setup earlier

As mentioned above when you query the database using this index you can tell FaunaDB which parts of the entry you want to return.

You can do this by adding "values" but be careful to enter the values exactly as they appear below because (on the FaunaDB free tier) you can’t amend these after you’ve created them so if there’s a mistake you’ll have to delete the index and start again... bummer!

The values you need to add are as follows:

- ref
- data.isApproved
- data.slug
- data.date
- data.name
- data.comment

After you've added all the values you can click **SAVE**

## [Get all comments](#get-all-comments)

<Divider />

```javascript
// boop.js
...
// GET ALL COMMENTS
getAllComments: async () => {
   const results = await client.query(
     q.Paginate(q.Match(q.Index("get-all-comments")))
   );
   console.log(JSON.stringify(results, null, 2));
   return results.data.map(([ref, isApproved, slug, date, name, comment]) => ({
     commentId: ref.id,
     isApproved,
     slug,
     date,
     name,
     comment,
   }));
 },
...
```

<Divider />

The breakdown of this function is as follows

- `client` is the FaunaDB client instance
- `query` is a method to get data from FaunaDB
- `q` is the instance of `faunadb.query`
- `Paginate` paginates the responses
- `Match` returns matched results
- `Index` is the name of the _Index_ you just created

The shape of the returned result here is an array of the same shape you defined in the _Index_ "values"

If you run the following you should see the list of all the comments you created earlier

<Divider />

```sh
node boop getAllComments
```

<Divider />

## [Get comments by slug](#get-comments-by-slug)

You're going to take a similar approach as above but this time create a new _Index_ that allows you to query FaunaDB in a different way. The key difference here is that when you **get-comments-by-slug** you'll need to tell FaunaDB about this specific **term** and you can do this by adding `data.slug` to the _Terms_ field.

<Divider />
<Img fluid={props.embedded.image5.fluid} />
<Divider />

- Go to **INDEX** and click **NEW INDEX**
- Name the index, i’ve called this one `get-comments-by-slug`
- Set the **source collection** to the name of the collection you setup earlier
- Add `data.slug` in the terms field

The values you need to add are as follows:

- ref
- data.isApproved
- data.slug
- data.date
- data.name
- data.comment

After you've added all the values you can click SAVE

<Divider />

```javascript
// boop.js
...
// GET COMMENT BY SLUG
getCommentsBySlug: async () => {
  const slug = "/posts/some-post";

  const results = await client.query(
    q.Paginate(q.Match(q.Index("get-comments-by-slug"), slug))
  );
  console.log(JSON.stringify(results, null, 2));
  return results.data.map(([ref, isApproved, slug, date, name, comment]) => ({
    commentId: ref.id,
    isApproved,
    slug,
    date,
    name,
    comment,
  }));
},
...
```

<Divider />

The breakdown of this function is as follows

- `client` is the FaunaDB client instance
- `query` is a method to get data from FaunaDB
- `q` is the instance of `faunadb.query`
- `Paginate` paginates the responses
- `Match` returns matched results
- `Index` is the name of the _Index_ you just created

The shape of the returned result here is an array of the same shape you defined in the _Index_ "values" you can create this shape in the same way you did above and be sure to add a value for terms. Again be careful to enter these with care.

If you run the following you should see the list of all the comments you created earlier but for a specific `slug`

<Divider />

```sh
node boop getCommentsBySlug
```

<Divider />

## [Approve comment by id](#approve-comment-by-id)

When you create a comment you manually set the `isApproved` value to false. This prevents the comment from being shown in the app until you approve it.

You'll now need to create a function to do this but you'll need to hard-code a `commentId`. Use a `commentId` from one of the comments you created earlier

<Divider />

```javascript
// boop.js
...
// APPROVE COMMENT BY ID
approveCommentById: async () => {
  const commentId = '263413122555970050'

  const results = await client.query(
    q.Update(q.Ref(q.Collection(COLLECTION_NAME), commentId), {
      data: {
        isApproved: true,
      },
    })
  );
  console.log(JSON.stringify(results, null, 2));
  return {
    isApproved: results.isApproved,
  };
},
...
```

<Divider />

The breakdown of this function is as follows

- `client` is the FaunaDB client instance
- `query` is a method to get data from FaunaDB
- `q` is the instance of `faunadb.query`
- `Update` is the FaundaDB method up update an entry
- `Ref` is the unique FaunaDB ref used to identify the entry
- `Collection` is area in the database where the data is stored

If you've hard coded a `commentId` you can now run the following in your CLI

<Divider />

```sh
node boop approveCommentById
```

If you run the `getCommentsBySlug` again you should now see the `isApproved` status of the entry you hard-coded the `commentId` for will have changed to `true`

<Divider />

```sh
node boop getCommentsBySlug
```

<Divider />

These are all the operations required to manage the data from the app.

In the repo if you have a look at `apollo-graphql.js` which can be found in `functions/apollo-graphql` you'll see the all of the above operations. As mentioned before the hard-coded values are replaced by `args`, these are the values passed in from various parts of the app.

## [Netlify](#netlify)

Assuming you've completed the Netlify sign up process or already have an account with Netlify you can now push the demo app to your GitHub account.

To do this you'll need to have initialize git locally, added a remote and have pushed the demo repo upstream before proceeding.

You should now be able to link the repo up to Netlify's [Continuous Deployment](https://docs.netlify.com/configure-builds/get-started/).

If you click the "New site from Git" button on the Netlify dashboard you can authorize access to your GitHub account and select the `gatsby-fauna-comments` repo to enable Netlify's Continuous Deployment. You'll need to have deployed at least once so that we have a pubic URL of your app.

The URL will look something like this `https://ecstatic-lewin-b1bd17.netlify.app` but feel free to rename it and make a note of the URL as you'll need it for the Netlify Identity step mentioned shortly

<Divider />
<Img fluid={props.embedded.image6.fluid} />
<Divider />

## [Environment Variables Pt. 2](#environment-variables-part-2)

In a previous step you added the FaunaDB database secret key and collection name to your `.env` files(s). You'll also need to add the same to Netlify's **Environment variables**.

- Navigate to Settings from the Netlify navigation
- Click on **Build and deploy**
- Either select **Environment** or scroll down until you see **Environment variables**
- Click on **Edit variables**

Proceed to add the following

```javascript
GATSBY_SHOW_SIGN_UP = false
GATSBY_FAUNA_DB = you FaunaDB secret key
GATSBY_FAUNA_COLLECTION = you FaunaDB collection name

```

While you're here you'll also need to amend the **Sensitive variable policy**, select _Deploy without restrictions_

## [Netlify Identity Widget](#netlify-identity-width)

I mentioned before that when a comment is created the `isApproved` value is set to `false`, this prevents comments from appearing on blog posts until you (the admin) have approved them. In order to become admin you'll need to create an _identity_.

You can achieve this by using the [Netlify Identity Widget](https://github.com/netlify/netlify-identity-widget).

If you've completed the Continuous Deployment step above you can navigate to the Identity page from the Netlify navigation.

<Divider />
<Img fluid={props.embedded.image7.fluid} />
<Divider />

You wont see any users in here just yet so lets use the app to connect the dots, but before you do that make sure you click **Enable Identity**

_Before you continue i just want to point out you'll be using `netlify dev` instead of `gatsby develop` or `yarn develop` from now on. This is because you'll be using some "special" Netlify methods in the app and staring the server using `netlify dev` is required to spin up various processes you'll be using._

- Spin up the app using `netlify dev`
- navigate to [http://localhost:8888/admin/](http://localhost:8888/admin/)
- Click the **Sign Up** button in the header

You will also need to point the Netlify Identity widget at your newly deployed app URL. This was the URL i mentioned you'll need to make a note of earlier, if you've not renamed your app it'll look something like this `https://ecstatic-lewin-b1bd17.netlify.app/` There will be a prompt in the pop up window to **Set site's URL**.

You can now complete the necessary sign up steps.

After sign up you'll get an email asking you to confirm you identity and once that's completed refresh the Identity page in Netlify and you should see yourself as a user.

It's now login time, but before you do this find `Identity.js` in `src/components` and temporarily un-comment the `console.log()` on line 14. This will log the Netlify Identity user object to the console.

- Restart your local server
- Spin up the app again using `netlify dev`
- Click the _Login_ button in the header

If this all works you should be able to see a console log for `netlifyIdentity.currentUser:` find the `id` key and copy the value.

Set this as the value for `GATSBY_ADMIN_ID =` in both `.env.production` and `.env.development`

You can now safely remove the `console.log()` on line 14 in `Identity.js` or just comment it out again.

```javascript
GATSBY_ADMIN_ID = your Netlify Identity user id
```

...and finally

- Restart your local server
- Spin up the app again using `netlify dev`

<Divider />

Now you should be able to login as "Admin"... hooray!

Navigate to [http://localhost:8888/admin/](http://localhost:8888/admin/) and Login.

It's important to note here you'll be using **localhost:8888** for development now and NOT **localhost:8000** which is more common with Gatsby development

Before you test this in the deployed environment make sure you go back to Netlify's **Environment variables** and add your Netlify Identity user `id` to the Environment variables!

- Navigate to Settings from the Netlify navigation
- Click on **Build and deploy**
- Either select **Environment** or scroll down until you see **Environment variables**
- Click on **Edit variables**

Proceed to add the following

```javascript
GATSBY_ADMIN_ID = your Netlify Identity user id

```

If you have a play around with the app and enter a few comments on each of the posts then navigate back to Admin page you can choose to either **approve** or **delete** the comments.

Naturally only approved comments will be displayed on any given post and deleted ones are gone forever.

If you've used this tutorial for your project i'd love to hear from you [@pauliescanlon](https://twitter.com/PaulieScanlon)
