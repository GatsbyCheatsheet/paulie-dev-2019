---
title: MDX Embedded Images and Theme UI Components
tags: ["React", "Gatsby", "JavaScript", "MDX"]
date: 2020-04-18
status: draft
author: Paul Scanlon
featuredImage: svg-icon-systems.jpg
---

In this post i'm going to show you a cool little trick to help you inject images in to the body of your posts using `frontmatter`.

I'm going to assume your `frontmatter` already includes fields for the title and perhaps a date but let's add one more field called `embeddedImages`

```javascript
// some-post.mx

---
title: Lovely stuff!
date: 2020-04-17
embeddedImages:
- local-image-1.jpg
- local-image-2.jpg
- local-image-3.jpg

---

```

We now need to amend the GraphQL query that handles getting your `frontmatter` from MDX and add to it `embeddedImages` with a `childImageSharp` query. You can use `fixed` or `fluid` or both.

```javascript
...
frontmatter {
  title
  date
  embeddedImages {
    childImageSharp {
      fluid {
        ...GatsbyImageSharpFluid
      }
      id
    }
  }
}
...
```

If you've added images local to an .mdx post and named them as above you should at this point be able to run a GraphiQL query and see the image data returned.

If that works let's move on to the next bit.

We need to add a prop to the `MDXRenderer` so find that in your code base and add `embeddedImages`

```javascript
<MDXRenderer embeddedImages={}>{body}</MDXRenderer>
```

Next we need to pass our new prop some data.

```javascript
...
const IMAGE_KEY = "image";

  const imageData = query.frontmatter.embeddedImages.reduce((images, image, index) => {
      images[`${IMAGE_KEY}${index + 1}`] = images[`${IMAGE_KEY}${index + 1}`] || {
        ...image.childImageSharp,
      };
      return images;
    }, {});

    return (
        <MDXRenderer embeddedImages={imageData}>{body}</MDXRenderer>
    )

...

```

What this little reduce method does is loop over the results for `embeddedImages` returned by your GraphQL query, and creates a new and more pleasant looking object.

```javascript
embeddedImages : {

    image1 {
        ...
    },

    image2: {
        ...
    }
}
```

This is going to make it easier to use when we're back in MDX.

## crap

If you've been working with Gatsby for a while you'll no doubt have encountered `gatsby-image`... If you haven't in short it's a really cool way to load and optimise images using GraphQL queries. You can read more about [gatsby-image here](https://www.gatsbyjs.org/packages/gatsby-image/#gatsby-image)

To use `gatsby-image` your code would look something like this ðŸ‘‡

```javascript
// some-file.js

import React from "react"
import { useStaticQuery, graphql } from "gatsby"

const AnImage ({ data }) => {
  const getImage = () => {
    return useStaticQuery(graphql`
      query {
        file(absolutePath: { regex: "/some-image.jpg/" }) {
          childImageSharp {
            fluid {
              ...GatsbyImageSharpFluid
            }
          }
        }
      }
    `)
  }

  return <img src={getImage().childImageSharp.fluid.src} />
}

export default AnImage

```

This is fine but you'll notice this is a React component and has within it a hard coded value for the name of an image the GraphQL should find before processing it with `gatsby-image`.

In practical terms you probably won't ever use `gatsby-image` in this way because it would mean creating a React component for each and every image you'd like to process, it does however explain the concept, let's move on.

When building a blog for instance it likely you'll use markdown instead of JavaScript to create your pages and in this post i'm going to be talking about MDX which is kind of like markdown but much more powerful. In short MDX is like markdown but it also has the ability to render React components, when i first understood this it blew my tiny mind!
